

I. Thuật toán tìm kiếm

2 thuật toán chính : 
    tìm kiếm tuyến tính linear search O(n): Duyệt 1 vòng for tìm kiếm -> có thể áp dụng cho cả mảng đã sắp xếp hoặc không sắp xếp
    tìm kiếm nhị phân binary search O(logn): Duyệt chia nhỏ và thu gọn mảng -> áp dụng cho mảng đã sắp xếp


int bin_search(int a[], int l, int r, int value){
    if(l > r) return -1;
    int m = (l + r)/2;
    if(a[m] == value) return m;
    else if(a[m] > value) return bin_search(a, l, m - 1, value);
    else return bin_search(a, m + 1, r, value);
}

// binary search thông thường không đệ quy
int bin_no_recursion(int a[], int l, int r, int v){
    while(l <= r){
        int mid = (l + r)/2;
        if(a[mid] == v) return mid;
        else if(a[mid] > v) r = mid - 1;
        else l = mid + 1;
    }
    return -1;
}

// binary search : tìm kiếm vị trí đầu tiên xuất hiện trong binary search
int firstPos(int a[], int l, int r, int v){
    int res = -1;
    while(l <= r){
        int mid = (l + r)/2;
        if(a[mid] == v){
            res = mid;
            // tìm kiếm xem bên trái có còn nữa ko
            r = mid - 1;
        }
        else if(a[mid] > v){
            r = mid -1;
        }
        else l = mid + 1;
    }
    return res;
}

// binary search : tìm kiếm vị trí cuối cùng xuất hiện trong binary search
int lastPos(int a[], int l, int r, int v){
    int res = -1;
    while(l <= r){
        int mid = (l + r)/2;
        if(a[mid] == v){
            res = mid;
            // tìm kiếm xem bên phải có còn nữa không
            l = mid + 1;
        }
        else if(a[mid] > v){
            r = mid -1;
        }
        else l = mid + 1;
    }
    return res;
}

II. Lower_bound, Upper_bound :logn
    lower_bound() : tìm vị trí đầu tiên của phần tử >= x trong mảng , vector tăng dần
    nếu không tìm thấy phần tử >= x, thì trả về a + n , a.end()
    upper_bound() : tìm vị trí đầu tiên của phần tử > x trong mảng, vector tăng dần
    nếu không tìm thấy phần tử > x, thì trả về a + n , a.end()

Áp dụng trong set và map : tuy khó nhưng rất mạnh
    
    Với set :
        tìm được giá trị của phần tử >= 3
        auto it = se.upper_bound(20);
        if(it == se.end()) cout << "Ko co" << endl;
        else cout << *it << endl;
        vị trí trong set
        int dis = distance(se.begin(), it);
        cout << dis << endl;
    Với map :
        Y hệt set nhưng áp dụng được với key