I. Set
- được xây dựng trên bst
- rất mạnh
- sử dụng 3 thằng chính là :
set
multiset
unordered_set
ordered_set
- set chỉ được lưu các phần tử không trùng nhau
- tự sắp xếp tăng dần luôn
- duyệt bằng for each hoặc iterator
- insert : logn -> them
- find : logn  -> tim
- count : logn -> Check xem xuất hiện bao nhiêu lần 
- erase : logn -> xoa
Nếu tìm thấy thì trả về iterator của phần tử tìm kiếm
không thấy thì trả về se.end()

- multiset có thể lưu được các phần tử trùng nhau
- có thể tự cân bằng
- nếu xóa phần tử trong multiset : nếu xóa bằng erase + giá trị : xóa hết
                                       xóa bằng iterator : xóa 1 phần tử

- unordered_set : không lưu phần tử trùng nhau và mảng sẽ ko sắp xếp
set xây dựng bằng bst
unordered_set xây dựng bằng hash table

- bài toán : 
+ lọc ra các phần tử khác nhau trong mảng

Dùng set khi:
Cần duyệt các phần tử theo thứ tự tăng dần.
Cần lower_bound / upper_bound để tìm phần tử gần nhất.
Muốn hiệu năng ổn định trong mọi tình huống O(log n)

Dùng unordered_set khi:
Chỉ cần kiểm tra sự tồn tại, chèn, xóa.
Không cần thứ tự.
Muốn tốc độ trung bình tốt hơn.

II.Map
map cực kì mạnh

<key, value> -> key là duy nhất không thể giống nhau
khai báo : map<dt1,dt2>
insert({key, value}) : logn
map[key] = value  => mp.insert({key, value})
size()
find(x) : logn -> trỏ về iterator của phần tử , không thì trỏ về end()
count(x) : logn -> nếu chỉ muốn biết nó có tồn tại hay không thì dùng count
erase(key) : logn -> xóa thông qua key và xóa thông qua value
tự khắc tăng tần xuất lên 1 nếu chưa có key trong map
duyệt thông qua for each : pair, iterator
it->first , it->second
thứ tự key tăng dần

multimap có thể lưu cùng key
nhưng ko gán được mp[key] vì có nhiều cặp có cùng value

unordered_map : lưu thứ tự không theo trật tự , không lưu được key trùng nhau.
trường hợp tốt nhất có thể đạt đến O(1)

III.Sort

sort : nlogn (<= 10^6)
stable_sort
sort vector : sort(a.begin(), a.end())
sort(a.begin() + x, a.begin() + y + 1)
comparator : compare
custom comparator
a đứng trước , b đứng sau 
đúng thứ tự rồi thì trả về true
chưa đúng thì trả vè false


intro sort : quicksort + heapsort : non-stable => sắp xếp sẽ không trả về kết quả như thứ tự đã nhập
stable sort : merge sort => trả về kết quả như đúng thứ tự đã nhập
Ví dụ : 
bool cmp(pair<int, int> a, pair<int, int> b){
    if(a.second != b.second) return a.second > b.second;
    else return a.first < b.first;
}